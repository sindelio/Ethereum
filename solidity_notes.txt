GENERAL CONCEPTS

Solidity is a high level programming language, contract oriented. In other words, Solidity is an object oriented programming language, whereas the objects of interest are contracts. So we can expect everything an object oriented language has, such as Python and Java, from Solidity. In fact, it supports:

- Inheritance and multiple inheritance
- Constructors
- Polymorphism
- Interfaces
- Public, private, internal and external functions and variables (except external variables)
- Maps

And also:

- User defined types
- Libraries

Solidity is a statically typed language, meaning that constraints are enforced in compilation time, instead of runtime. 

SMART CONTRACTS

A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.


SYNTAX KEYWORDS AND NOTES

- is
	Used for inheritance and multiple inheritance. Contracts can inherit functions, state variables and everything else from their supercontracts.
- contract
	Used to declare a contract(class) that can be instantiated(deployed) in the EVM.
- function
	Used to declare a function. A function can be called with the order of the parameters changed by passing an object to it. It is important to distinguish 2 types of functions: Read-only (constant or view) functions, makes no change to state, costs no Gas. Transactional functions, makes changes to state, costs Gas. A function is public by default.
	Functions with no names are used as a response to payments sent to the contract. There can only be one nameless function per contract and it should be one the payable type.
- var
	Used to declare a state variable. Defaults to internal, can't be external.
- modifier
	Used to declare a modifier, which is a special function that modifies other functions. Modifiers are useful to reuse code in different functions. Syntax: "function name() modifier{}". Inside the modifier, the body function is replaced by "_;".
- public
	Specifies that a state variable or function is viewable by the contract itself, its childs, external contracts and external calls. 
	When the public keyword is used as follows:

	address public minter;

	The compiler will create code for a getter function similar to:

	function minter() returns (address) { return minter; }

	Adding a function with the same name would not work as above, because we would have a variable and a function with the same name, both created by the code, and the compiler would not know what to do with them.
- private
	Specifies that a state variable or function is viewable only by it's contract. The subcontracts, or childs, can't call a private function from their parents.
- internal
	Specifies that a state variable or function is viewable by it's smart contracts and it's childs.
- external
	Specifies that a function can only be called by outside smart contracts. External functions are interesting to recevive large amounts of data, because they use less Gas than public functions for the same purpose.
- view
	Specifies that a function can only read from storage. A view functions costs no Gas. A normal function can read and write to storage, but it costs Gas.
- constant
	Alias for view, but deprecated.
- pure
	Specifies that a function can't read or write to storage. A pure function costs no Gas. A normal function can read and write to storage, but it costs Gas.
- returns
	Specifies the expected returned variables from a function. A function can return multiple variables.
- return
	Classic return statement. One can also specify the returned variable inside the function, ommiting the return statement from the function "header"/"specification".
- payable
	A function modifier that allows functions to receive Ether.
- this
	GOTTA STUDY 
- event
	Used to declare an event. Events are logged into the Blockchain in the receipts part. Events are important for auditions and code clarity. Events are useful to light clients to sync with the Blockchain.
- assert
	Assert and require are special functions that help in dealing with exceptions. Assert guarantees that a certain internal state never occurs.
- require
	Assert and require are special functions that help in dealing with exceptions. Throw is deprecated in the newer versions of Solidity. Require should be used instead of throw. Require checks on externally provided input data. 
- pragma
	Pragmas are instructions for the compiler about how to treat the source code.
- emit
	Used to emit an event.
- mapping
	Creates complex data types through mapping one type to another. That is, it creates functions from one domain to another. Although, the maps don't have a way to look up all the values or all the keys that are being used. If these operations are required, one should use a more complex data type.
	For a code like this:

	mapping (address => uint) public balances;

	The compiler creates a getter function similar to:

	function balances(address _account) public view returns (uint) {
    	return balances[_account];
	}


DATA TYPES

- int
- uint
- unit256
- uint8
- address
	160-bit value that does not allow any arithmetic operations. Allows relational operations tho.
- bool
- string
- bytes


GLOBALLY AVAILABLE VARIABLES:

- msg
	A magic global variable that contains some properties which allow access to the blockchain. msg.sender is always the address where the current (external) function call came from. 

BUILT IN FUNCTIONS:

- msg.sender.send()
	Used to transfer Ethereum from one account to another.

UNITS:

- now
	Used to get the time and date of the present moment.
- ether
	Ether cryptocurrency.
- 



ETHEREUM VIRTUAL MACHINE (EVM)

The Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts.

Accounts:

There are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account.
Regardless of whether or not the account stores code, the two types are treated equally by the EVM.
Every account has a persistent key-value store mapping 256-bit words to 256-bit words called storage.
Furthermore, every account has a balance in Ether (in “Wei” to be exact) which can be modified by sending transactions that include Ether.

/*
The EVM is composed of:

- A stack of 32 byte addresses up to 1024 addresses total. Recursions aren't recommended as they can easily blow up the stack.
- A memory. An infinetely expanding byte array but gets pricier in Gas as it builds up. It holds the present state of the Ethereum Blockchain.
- A storage. A permanent contract storage, read and write.
- Environment Variables.
- Logs.
- Sub-Calling. Operation by which a contract can call another contract.

Gas: a mechanism to avoid the halting problem. It consists in payment for computational steps in the EVM.

RLP: Recursive Length Prefix Encoding. Basically puts the lenght before and a code after, in this syntax: lenght x code. used extensively in the EVM.
*/

ETHEREUM BLOCKCHAIN

A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. 

Transactions:

The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is applied to the database, no other transaction can alter it.
As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified.
Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer money from it.

Blocks:

Groups of transactions.
The blocks form a linear sequence in time and that is where the word “blockchain” derives from. Blocks are added to the chain in rather regular intervals - for Ethereum this is roughly every 17 seconds.

Every block header contains 3 tries:
 	
- Transactions
- State
- Receipts

State. Consists of key-values mapping addresses to account objects. Every account contains 4 pieces of data:
	
- Nonce. Proof of work that allows one to insert append transactions to the Blockchain.
- Balance. In Ether (ETH). 
- Code hash. SHA most likely.
- Storage trie root.

Transactions. Contains 7 values:
	
- Nonce (anti replay attack)
- Gasprice (amount of ether per unit gas)
- Startgas (maximum gas consumable)
- To (destination address)
- Value (amount of ETH to send)
- Data (readable by contract code)
- v, r, s (ECDSA cryptography signature values)

Receipts. Every transaction has a corresponding receipt. Has a few pieces of data:

- Intermediate state root (hash that represents the state after the transaction is executed)
- Cumulative gas used (total amount of gas used in that block including that transaction)
- Logs (append-only, not readable by contracts)

Mining: Process by which blocks of transactions are appended in Ethereum Blockchain. It consists in the resolution of a math problem by the nodes, and whichever node solves the problem first gets the right to append a block, a.k.a. set of transactions,  to the Blockchain. Mining in Ethereum is GPU friendly, with a memory hardness approach. This means that memory is the most important factor, not computational power.

Merkle tree: Tree data structure that allows for efficient verifiable proof that a transaction was included in a block. Also called hash trees, because it sores the hashes of the data in the nodes of the tree.

Trie: Tree data structure that allows for efficient lookups or searches. Also called digital tree or prefix tree or radix tree.

Merkle-patricia-tree: A special type of trie used in the Ethereum Blockchain. Also called patricia tree, this type of trie has some improvements over the normal trie. In the Ethereum Blockchain, all entries in the patricia tree are encoded using the RLP (Recursive Length Prefix).

SECURITY MEASURES AND GOOD PRACTICES

Security recommendations list:
	
1. Fail as early and loudly as possible. Meaning: use exceptions! a.k.a. require() and assert().
2. Favor pull over push payments.
3. Order your function code: conditions => actions => interactions. A.k.a checks => effects => interactions pattern.
4. Be aware of platform limits. EVM has a lot of constraints, such as Gas and transaction speed.
5. Write tests, do audits. Can't fail in the mainnet!
6. Use fault tolerance and automatic bug bounties.
7. Limit the amount of funds deposited.
8. Write simple and modular code.
9. Don’t write all your code from scratch.

Common pitfalls:

1. Private information leaked.
2. Re-entrancy attacks.
3. Loops can trigger Gas limit.
4. Ether send function can fail.
5. Timestamp can be manipulated by miners.
6. Data overflow and underflow. Example: loop with iterator i of type int, instead of type uint256. i will easily reach it's limit and the loop will malfunction.

SOLIDITY INTEGRATIONS

- Sublime language syntax package for Solidity
	Solidity syntax highlighting for SublimeText editor.
- Vim Solidity & Vim Synthastic
	Plugins for the Vim editor providing synthax highlighting and compile checking.

COMPILERS

- Remix
	Online IDE with a compiler, has no deployer.
- Solc
	Local, offline compiler. Has no deployer either.
- Visual Studio Extension
	Solidity plugin for Microsoft Visual Studio that includes a Solidity compiler.

TEST SUITES

- Truffle
	Local compiler, linker, deployer and binary manager. Very customizable. 
- Testrpc
	Local Blockchain abstraction built in Javascript backend (Node.js) for test purposes.
- Geth
	Command Line Interface - CLI, for interacting with Blockchain networks and abstractions. Written in Go. Also has versions in C++ (named ETH) and Python (named Pyetapp)
- Metamask
	Browser extension that allows interaction with websites that have Ethereum related services, such as payments. Has a local Ethereum wallet and a contract watcher built in.
- Withpragma
	Online Integrated Development Interface - IDE, with a contract compiler, deployer and watcher.
- Etheratom
	Plugin for the Atom editor that features syntax highlighting, compilation and a runtime environment (Backend node & VM compatible).

OTHER SOLIDITY TOOLS

- Doxity
	Documentation Generator for Solidity.
- Dapp
	Build tool, package manager, and deployment assistant for Solidity.

GOOD MATERIAL

- Documentation. 
		https://solidity.readthedocs.io/en/develop/
- (Tutorial) Create your own cryptocurrency with Ethereum.
		https://www.ethereum.org/token
- (Course) Basics of Solidity - Bitdegree.
		https://solidity.bitdegree.org/
- (Tutorial) The Hitchhiker’s Guide to Smart Contracts in Ethereum.
		https://blog.zeppelin.solutions/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05
- (Tutorial) Onward with Ethereum Smart Contract Security.
		https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702
- (Book) Mastering Ethereum.
- (Book) Introducing Ethereum and Solidity: Foundations of Cryptocurrency and Blockchain programming for Beginners.
- (Book) Building Blockchain Projects: Building Decentralized Application with Ethereum and Solidity.
- (Book) Ethereum: Blockchains, Digital Assets, Smart Contracts, Decentralized Digital Organizations.
 
ETHEREUM WALLETS

- Ethereum Wallet
	Official wallet. A desktop wallet that supports contract deployment and watching. Can be used with the mainnet or the test nets, and also have a light client.
	Found at: https://github.com/ethereum/mist/releases
- MyEtherWallet
	Online wallet. Supports contract deplyoment and contract watching. Can be used with the mainnet or the test nets.
	Found at: https://www.myetherwallet.com/

QUESTIONS

? This statement
? Indexed attributes on events??? Up to 3 parameters can have the indexed attribute in an event.
? Understand better the trie, radix tree and merkle tree.

TODO LIST

-1. Write about the double spending attack
0. Read the entire Solidity documentation (20%)
1. Test a crowdfunding smart contract
2. Check the book "Introducing Ethereum and Solidity: Foundations of Cryptocurrency and Blockchain programming for Beginners"
3. Study other TOKEN standards aside from ERC20
4. Study BAT smart contract
5. Study Zepellin secure smart contracts
6. Study the Dapp Solidity Tool
7. Create my own Dapp


MILESTONES

1. Created my own Ethereum token. the Sinds Coin!
2. Succesfully tested a smart contract using Truffle and Testrpc!
3. Successfully deployed a smart contract using Metamask and Withpragma!
